from enum import Enum
from typing import NamedTuple

# Data definitions

# Classes imported from dependencies:
#     Bio.SeqRecord
#     Bio.SeqFeature

"""
The annotate module heavily leverages these two classes. 
    - The input genome is converted to a list of seqrecords, one for each chromosome / contig in the genbank file.
    - Each seqrecord contains a list of seqfeatures, which are all of the annotations. Every gene, CDS, RNA, intergenic
        region, etc. is a seqfeature.
    - The data types below are additional pieces of information that pseudofinder will collect about each feature. These
        can be accessed within each seqfeature by seqfeature.qualifiers, which is a dictionary of additional info.
    - For example, you can access a list of blast hits stored as List[BlastHit] through SeqFeature.qualifiers['hits'].
"""


class BlastHit(NamedTuple):  # An individual blast hit to a region.
    blast_type: str
    query: str
    subject_accession: str
    percent_ident: str
    length: int  # reported in aa for blastp and nt for blastx. see blasthit_length()
    mismatch: int
    gapopen: int
    q_start: int
    q_end: int
    s_start: int
    s_end: int
    evalue: int
    bitscore: float
    stitle: str


class SleuthData(NamedTuple):   # Data generated by the sleuth module
    reference_locus: str
    target_locus: str
    ani: float
    aai: float
    ref_length: float
    aln_query_cov: float
    start: bool
    loss_of_preferred_start: bool
    gain_of_preferred_start_codon: bool
    stop_codon: bool
    internal_stops: int
    first_stop_codon: int
    out_of_frame_inserts: int
    out_of_frame_dels: int
    inframe_inserts: int
    inframe_dels: int
    total_inserts: int
    total_deleted_bases: int
    ds: float
    ds_no_mercy: float
    dsds: float
    delta_ds: float
    dnds: float
    dnds_no_mercy: float
    full_seq: str
    mercy_aln: str
    no_mercy_aln: str
    full_ref_seq: str
    mercy_aln_ref: str
    no_mercy_aln_ref: str


class PseudoType:  # Use this class to designate what kind of pseudogene a particular feature is.
    class Input(Enum):  # Pseudogenes declared in the original genbank file
        general = "Input gbk feature.type is 'pseudo' but we don't have a reason why"
        indel = "Input feature.seq is not a multiple of 3"
        internalstop = "Stop codon (*) is present in input feature.seq"

    class Sleuth(Enum):  # Pseudogenes derived from the sleuth module
        dnds = "Pseudogene based on elevated dN/dS"
        frameshift = "Pseudogene based on significant frameshift-inducing indel(s)"
        start_codon = "Missing start codon"
        stop_codon = "Missing stop codon"
        internal_stop = "Internal stop codon"

    class Blast(Enum):  # Pseudogenes derived from blast results
        truncated = "CDS is too short based on length relative to blast hits"
        short_alignment = "Alignment of CDS to blast homologs is too short"
        long = "CDS is too long relative to blast hits"
        fragmented = "Pseudogene composed of multiple input features"
        intergenic = "Pseudogene recovered from intergenic space"

    class NotPseudo(Enum):  # Category for features that need a pseudotype but are not pseudogenes
        consumed = "Feature has been combined with other features (PseudoType.Blast.fragmented) and should no longer " \
                   "be considered its own pseudogene"
        intact = "Not a pseudogene"


# Global dictionary, which will be called to write the log file
StatisticsDict = {
                    'BlastpFilename': '',
                    'BlastxFilename': '',
                    'NumberOfContigs': 0,
                    'ProteomeOrfs': 0,
                    'FragmentedOrfs': 0,
                    'PseudogenesInput': 0,
                    'PseudogenesTotal': 0,
                    'PseudogenesShort': 0,
                    'PseudogenesFragmented': 0,
                    'PseudogenesIntergenic': 0,
                    'OutputFiles': [],
                    'dnds': 0,
                    'IntactORFs': 0
                  }